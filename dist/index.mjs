import e from"lodash";import t from"chalk";import r from"fs";import o from"mustache";import a from"path";import n from"sharp";import i from"url";import{createWorker as s}from"tesseract.js";const c={CHANNEL:"blue",SEPARATOR:175,REFLECT:false,LOG:true},f=a.resolve(i.fileURLToPath(import.meta.url),"..","..");let l=true;const h={info:t.gray,success:t.green,error:t.red,debug:t.yellow},d=(t,r,...o)=>{l&&console.log(h[t](`${(new Date).toISOString()}`,`[${e.upperFirst(r)}]`,...o))},m=(t,{channel:i="blue",separator:c=175,reflect:h=false,log:m=true}={})=>{l=m;const p=Date.now();return d("info","butcher","Starting"),new Promise((async(l,m)=>{try{const m=await(async(e,{channel:t="blue",separator:r=175}={})=>{const o=Date.now();d("info","cleaner","Starting");try{const a=n(e).extractChannel(t).raw();d("info","cleaner","Extracted",t,"channel");const{data:i,info:s}=await a.toBuffer({resolveWithObject:!0}),{width:c,height:f,channels:l}=s;let h=!1;const m=new Uint8ClampedArray(i.buffer).map(((e,t)=>(t%c==c-1&&e>5&&(h=!0),h&&e>r?0:255))),p=n(m,{raw:{width:c,height:f,channels:l}});d("info","cleaner","Cleaned pixels");const g=await p.trim().toBuffer({resolveWithObject:!0});d("info","cleaner","Trimed edges");const w={buffer:new Uint8ClampedArray(g.data.buffer),raw:{width:g.info.width,height:g.info.height,channels:g.info.channels},offset:{top:g.info.trimOffsetTop,left:g.info.trimOffsetLeft}},u={top:10,bottom:10,left:10,right:10,background:{r:255,g:255,b:255}},b=n(w.buffer,{raw:w.raw}).extend(u);d("info","cleaner","Extended edges");const y=await b.png().removeAlpha().toBuffer();return d("success","cleaner","Done in",(Date.now()-o)/1e3+"ms."),{buffer:y,width:c,height:f,crop:{top:Math.abs(w.offset.top)-u.top,left:Math.abs(w.offset.left)-u.left,width:w.raw.width+u.left+u.right,height:w.raw.height+u.top+u.bottom}}}catch(e){throw d("error","cleaner",e.message),e}})(t,{channel:i,separator:c}),g=await(async t=>{const r=Date.now();d("info","extractor","Starting");try{let o=null;const n=s({gzip:!0,cacheMethod:"refresh",langPath:a.resolve(f,"data"),logger:({status:t})=>{o!==t&&(o=t,d("info","extractor",e.startCase(t)))}});await n.load(),await n.loadLanguage("eng"),await n.initialize("eng"),await n.setParameters({user_defined_dpi:"70"});const i=await n.recognize(t);await n.terminate();const c={pair:/^\w+(\s?)\/(\s?)\w+$/,entry:/^(enter|between|(\d+((\.\d+)?)))/i,stop:/^(stop|(\d+((\.\d+)?)))/i,targets:/^(target|(\d+((\.\d+)?)))/i},l=e=>e.match(/(\w+)/g),h=t=>{const r=t.match(/(\d+((\.\d+)?))/g);if(r)return e.filter(e.sortBy(e.map(r,(t=>e.toNumber(t)))))},m=e.reduce(i.data.lines,((t,r)=>(e.each(r.words,(o=>{const a=e.trim(o.text);e.each(t.patterns,((n,i)=>{if(a.match(n)){e.each(o.symbols,(({bbox:{x0:e,y0:r,x1:o,y1:a}})=>{t.coordinates.push({left:e,top:r,right:o,bottom:a})}));const n="pair"===i?l(a):h(a);if(n)return t.lines[i]=n,t.confidence.push(r.confidence),t.patterns=e.omit(t.patterns,[i]),!1}}))})),t)),{patterns:c,lines:{},coordinates:[],confidence:[]});return d("success","extractor","Done in",(Date.now()-r)/1e3+"ms."),{signal:m.lines,coordinates:m.coordinates,confidence:e.toSafeInteger(e.round(e.mean(m.confidence)))}}catch(e){throw d("error","extractor",e.message),e}})(m.buffer),w=[g.signal.pair,g.signal.entry,g.signal.stop,g.signal.targets];if(e.some(w,e.isEmpty))throw d("error","extractor","Invalid input"),new Error("Invalid input");const u={signal:g.signal,confidence:g.confidence};if(h){const i=await(async(t,{cleaned:i,extracted:s,reflect:c})=>{const l=Date.now();d("info","reflector","Starting");try{const h=a.resolve(f,"src","mask.mustache"),m=e.toString(r.readFileSync(h));d("info","reflector","Loading mask template");const p=e.map(s.coordinates,(({top:e,left:t,right:r,bottom:o})=>({top:i.crop.top+e,left:i.crop.left+t,width:r-t,height:o-e}))),g={top:e.min(e.map(p,"top")),left:e.min(e.map(p,"left")),bottom:e.max(e.map(p,(({top:e,height:t})=>e+t))),right:e.max(e.map(p,(({left:e,width:t})=>e+t)))},w=o.render(m,{width:i.width,height:i.height,coordinates:p});d("info","reflector","Rendred mask template");const u=[{input:new Buffer.from(w)}],b=await n(t).grayscale().composite(u).toBuffer();d("info","reflector","Composited mask layer");const y=await n(b).resize({width:680}).toBuffer({resolveWithObject:!0});d("info","reflector","Resized masked");const x=t=>e.floor(t*y.info.width/i.width),D=[{input:a.resolve(f,"src","tape.svg"),top:x(g.bottom)+20,left:0},{input:a.resolve(f,"src","butcher.svg"),top:y.info.height-280,left:x(g.right)+20}],v=await n(y.data).composite(D).sharpen().toBuffer();if(d("info","reflector","Composited ui layer"),e.isBoolean(c))return d("success","reflector","Done in",(Date.now()-l)/1e3+"ms."),v;const S=a.resolve(c);return r.writeFileSync(S,v),d("success","reflector","Done in",(Date.now()-l)/1e3+"ms."),S}catch(e){throw d("error","reflector",e.message),e}})(t,{cleaned:m,extracted:g,reflect:h});e.set(u,"reflect",i)}d("success","butcher","Done in",(Date.now()-p)/1e3+"ms."),l(u)}catch(e){d("error","butcher",e.message),m(e)}}))};export{c as CONST,m as butcher};