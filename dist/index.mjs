import e from"lodash";import t from"fs";import r from"mustache";import o from"path";import a from"sharp";import n from"url";import{createWorker as i}from"tesseract.js";const s={CHANNEL:"blue",SEPARATOR:175,REFLECT:false,LOG:true},c=o.resolve(n.fileURLToPath(import.meta.url),"..","..");let l=true;const f=(t,r,...o)=>{l&&console[t](`${(new Date).toISOString()}`,`[${e.upperFirst(r)}]`,...o)},h=(n,{channel:s="blue",separator:h=175,reflect:d=false,log:m=true}={})=>{l=m;const p=Date.now();return f("log","butcher","Starting"),new Promise((async(l,m)=>{try{const m=await(async(e,{channel:t="blue",separator:r=175}={})=>{const o=Date.now();f("log","cleaner","Starting");try{const n=a(e).extractChannel(t).raw();f("log","cleaner","Extracted",t,"channel");const{data:i,info:s}=await n.toBuffer({resolveWithObject:!0}),{width:c,height:l,channels:h}=s;let d=!1;const m=new Uint8ClampedArray(i.buffer).map(((e,t)=>(t%c==c-1&&e>5&&(d=!0),d&&e>r?0:255))),p=a(m,{raw:{width:c,height:l,channels:h}});f("log","cleaner","Cleaned pixels");const g=await p.trim().toBuffer({resolveWithObject:!0});f("log","cleaner","Trimed edges");const w={buffer:new Uint8ClampedArray(g.data.buffer),raw:{width:g.info.width,height:g.info.height,channels:g.info.channels},offset:{top:g.info.trimOffsetTop,left:g.info.trimOffsetLeft}},u={top:10,bottom:10,left:10,right:10,background:{r:255,g:255,b:255}},b=a(w.buffer,{raw:w.raw}).extend(u);f("log","cleaner","Extended edges");const y=await b.png().removeAlpha().toBuffer();return f("info","cleaner","Done in",(Date.now()-o)/1e3+"ms."),{buffer:y,width:c,height:l,crop:{top:Math.abs(w.offset.top)-u.top,left:Math.abs(w.offset.left)-u.left,width:w.raw.width+u.left+u.right,height:w.raw.height+u.top+u.bottom}}}catch(e){throw f("error","cleaner",e.message),e}})(n,{channel:s,separator:h}),g=await(async t=>{const r=Date.now();f("log","extractor","Starting");try{let a=null;const n=i({gzip:!0,cacheMethod:"refresh",langPath:o.resolve(c,"data"),logger:({status:t})=>{a!==t&&(a=t,f("log","extractor",e.startCase(t)))}});await n.load(),await n.loadLanguage("eng"),await n.initialize("eng"),await n.setParameters({user_defined_dpi:"70"});const s=await n.recognize(t);await n.terminate();const l={pair:/^\w+(\s?)\/(\s?)\w+$/,entry:/^(enter|between|(\d+((\.\d+)?)))/i,stop:/^(stop|(\d+((\.\d+)?)))/i,targets:/^(target|(\d+((\.\d+)?)))/i},h=e=>e.match(/(\w+)/g),d=t=>{const r=t.match(/(\d+((\.\d+)?))/g);if(r)return e.filter(e.sortBy(e.map(r,(t=>e.toNumber(t)))))},m=e.reduce(s.data.lines,((t,r)=>(e.each(r.words,(o=>{const a=e.trim(o.text);e.each(t.patterns,((n,i)=>{if(a.match(n)){e.each(o.symbols,(({bbox:{x0:e,y0:r,x1:o,y1:a}})=>{t.coordinates.push({left:e,top:r,right:o,bottom:a})}));const n="pair"===i?h(a):d(a);if(n)return t.lines[i]=n,t.confidence.push(r.confidence),t.patterns=e.omit(t.patterns,[i]),!1}}))})),t)),{patterns:l,lines:{},coordinates:[],confidence:[]});return f("info","extractor","Done in",(Date.now()-r)/1e3+"ms."),{signal:m.lines,coordinates:m.coordinates,confidence:e.toSafeInteger(e.round(e.mean(m.confidence)))}}catch(e){throw f("error","extractor",e.message),e}})(m.buffer),w=[g.signal.pair,g.signal.entry,g.signal.stop,g.signal.targets];if(e.some(w,e.isEmpty))throw f("error","extractor","Invalid input"),new Error("Invalid input");const u={signal:g.signal,confidence:g.confidence};if(d){const i=await(async(n,{cleaned:i,extracted:s,reflect:l})=>{const h=Date.now();f("log","reflector","Starting");try{const d=o.resolve(c,"src","mask.mustache"),m=e.toString(t.readFileSync(d));f("log","reflector","Loading mask template");const p=e.map(s.coordinates,(({top:e,left:t,right:r,bottom:o})=>({top:i.crop.top+e,left:i.crop.left+t,width:r-t,height:o-e}))),g={top:e.min(e.map(p,"top")),left:e.min(e.map(p,"left")),bottom:e.max(e.map(p,(({top:e,height:t})=>e+t))),right:e.max(e.map(p,(({left:e,width:t})=>e+t)))},w=r.render(m,{width:i.width,height:i.height,coordinates:p});f("log","reflector","Rendred mask template");const u=[{input:new Buffer.from(w)}],b=await a(n).grayscale().composite(u).toBuffer();f("log","reflector","Composited mask layer");const y=await a(b).resize({width:680}).toBuffer({resolveWithObject:!0});f("log","reflector","Resized masked");const x=t=>e.floor(t*y.info.width/i.width),D=[{input:o.resolve(c,"src","tape.svg"),top:x(g.bottom)+20,left:0},{input:o.resolve(c,"src","butcher.svg"),top:y.info.height-280,left:x(g.right)+20}],v=await a(y.data).composite(D).sharpen().toBuffer();if(f("log","reflector","Composited ui layer"),e.isBoolean(l))return f("info","reflector","Done in",(Date.now()-h)/1e3+"ms."),v;const S=o.resolve(l);return t.writeFileSync(S,v),f("info","reflector","Done in",(Date.now()-h)/1e3+"ms."),S}catch(e){throw f("error","reflector",e.message),e}})(n,{cleaned:m,extracted:g,reflect:d});e.set(u,"reflect",i)}f("info","butcher","Done in",(Date.now()-p)/1e3+"ms."),l(u)}catch(e){f("error","butcher",e.message),m(e)}}))};export{s as CONST,h as butcher};