"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),t=require("url"),a=require("lodash"),r=require("path"),o=require("sharp"),n=require("chalk"),i=require("mustache"),f=require("tesseract.js");function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var c=s(e),l=s(t),d=s(a),u=s(r),h=s(o),p=s(n),m=s(i);const w={CHANNEL:"blue",SEPARATOR:175,REFLECT:false},g=u.default.resolve(l.default.fileURLToPath("undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("index.cjs",document.baseURI).href),"..","..");let b=true;const y={info:p.default.gray,success:p.default.green,error:p.default.red,debug:p.default.yellow},x=(e,t,...a)=>{b&&console.log(y[e](`${(new Date).toISOString()}`,`[${d.default.upperFirst(t)}]`,...a))};exports.CONST=w,exports.butcher=(e,{channel:t="blue",separator:a=175,reflect:r=false,log:o=true}={})=>{b=o;const n=Date.now();return x("info","butcher","Starting"),new Promise((async(o,i)=>{try{const i=await(async(e,{channel:t="blue",separator:a=175}={})=>{const r=Date.now();x("info","cleaner","Starting");try{const o=h.default(e).extractChannel(t).raw();x("info","cleaner","Extracted",t,"channel");const{data:n,info:i}=await o.toBuffer({resolveWithObject:!0}),{width:f,height:s,channels:c}=i;let l=!1;const d=new Uint8ClampedArray(n.buffer).map(((e,t)=>(t%f==f-1&&e>5&&(l=!0),l&&e>a?0:255))),u=h.default(d,{raw:{width:f,height:s,channels:c}});x("info","cleaner","Cleaned pixels");const p=await u.trim().toBuffer({resolveWithObject:!0});x("info","cleaner","Trimed edges");const m={buffer:new Uint8ClampedArray(p.data.buffer),raw:{width:p.info.width,height:p.info.height,channels:p.info.channels},offset:{top:p.info.trimOffsetTop,left:p.info.trimOffsetLeft}},w={top:10,bottom:10,left:10,right:10,background:{r:255,g:255,b:255}},g=h.default(m.buffer,{raw:m.raw}).extend(w);x("info","cleaner","Extended edges");const b=await g.png().removeAlpha().toBuffer();return x("success","cleaner","Done at",(Date.now()-r)/1e3+"ms."),{buffer:b,width:f,height:s,crop:{top:Math.abs(m.offset.top)-w.top,left:Math.abs(m.offset.left)-w.left,width:m.raw.width+w.left+w.right,height:m.raw.height+w.top+w.bottom}}}catch(e){throw x("error","cleaner",e.message),e}})(e,{channel:t,separator:a}),s=await(async e=>{const t=Date.now();x("info","extractor","Starting");try{const a=f.createWorker();await a.load(),await a.loadLanguage("eng"),await a.initialize("eng"),x("info","extractor","Prepared worker"),await a.setParameters({user_defined_dpi:"70"});const r=await a.recognize(e);x("info","extractor","Recognized data"),await a.terminate();const o={pair:/^\w+(\s?)\/(\s?)\w+$/,entry:/^(enter|between|(\d+((\.\d+)?)))/i,stop:/^(stop|(\d+((\.\d+)?)))/i,targets:/^(target|(\d+((\.\d+)?)))/i},n=e=>e.match(/(\w+)/g),i=e=>{const t=e.match(/(\d+((\.\d+)?))/g);if(t)return d.default.filter(d.default.sortBy(d.default.map(t,(e=>d.default.toNumber(e)))))},s=d.default.reduce(r.data.lines,((e,t)=>(d.default.each(t.words,(a=>{const r=d.default.trim(a.text);d.default.each(e.patterns,((o,f)=>{if(r.match(o)){d.default.each(a.symbols,(({bbox:{x0:t,y0:a,x1:r,y1:o}})=>{e.coordinates.push({left:t,top:a,right:r,bottom:o})}));const o="pair"===f?n(r):i(r);if(o)return e.lines[f]=o,e.confidence.push(t.confidence),e.patterns=d.default.omit(e.patterns,[f]),!1}}))})),e)),{patterns:o,lines:{},coordinates:[],confidence:[]});return x("success","extractor","Done at",(Date.now()-t)/1e3+"ms."),{signal:s.lines,coordinates:s.coordinates,confidence:d.default.toSafeInteger(d.default.round(d.default.mean(s.confidence)))}}catch(e){throw x("error","extractor",e.message),e}})(i.buffer),l=[s.signal.pair,s.signal.entry,s.signal.stop,s.signal.targets];if(d.default.some(l,d.default.isEmpty))throw x("error","extractor","Invalid input"),new Error("Invalid input");const p={signal:s.signal,confidence:s.confidence};if(r){const t=await(async(e,{cleaned:t,extracted:a,reflect:r})=>{const o=Date.now();x("info","reflector","Starting");try{const n=u.default.resolve(g,"src","mask.mustache"),i=d.default.toString(c.default.readFileSync(n));x("info","reflector","Loading mask template");const f=d.default.map(a.coordinates,(({top:e,left:a,right:r,bottom:o})=>({top:t.crop.top+e,left:t.crop.left+a,width:r-a,height:o-e}))),s={top:d.default.min(d.default.map(f,"top")),left:d.default.min(d.default.map(f,"left")),bottom:d.default.max(d.default.map(f,(({top:e,height:t})=>e+t))),right:d.default.max(d.default.map(f,(({left:e,width:t})=>e+t)))},l=m.default.render(i,{width:t.width,height:t.height,coordinates:f});x("info","reflector","Rendred mask template");const p=[{input:new Buffer.from(l)}],w=await h.default(e).grayscale().composite(p).toBuffer();x("info","reflector","Composited mask layer");const b=await h.default(w).resize({width:680}).toBuffer({resolveWithObject:!0});x("info","reflector","Resized masked");const y=e=>d.default.floor(e*b.info.width/t.width),v=[{input:u.default.resolve(g,"src","tape.svg"),top:y(s.bottom)+20,left:0},{input:u.default.resolve(g,"src","butcher.svg"),top:b.info.height-280,left:y(s.right)+20}],D=await h.default(b.data).composite(v).sharpen().toBuffer();if(x("info","reflector","Composited ui layer"),d.default.isBoolean(r))return x("success","reflector","Done at",(Date.now()-o)/1e3+"ms."),D;const S=u.default.resolve(r);return c.default.writeFileSync(S,D),x("success","reflector","Done at",(Date.now()-o)/1e3+"ms."),S}catch(e){throw x("error","reflector",e.message),e}})(e,{cleaned:i,extracted:s,reflect:r});d.default.set(p,"reflect",t)}x("success","butcher","Done at",(Date.now()-n)/1e3+"ms."),o(p)}catch(e){x("error","butcher",e.message),i(e)}}))};